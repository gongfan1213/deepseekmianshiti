//合并有序数组，要求时间复杂度O(m+n)，空间复杂度O(1)
//反向比较，也就是从两个数组的末尾开始比较，较大的元素放到num1的末尾，就是预留空间的末尾，
//因为num1的后面是空的，不会覆盖还没有处理的元素，避免覆盖的问题不需要额外的空间
//c初始化三个指针
//从数组的末尾开始比较，较大的元素放到num1的末尾就是预留空间的末尾
//因为Number1的后面是空的，不会覆盖还没有处理的元素，避免覆盖的问题，不需要额外的空间
//较大的数字放到num1的末尾就是m+n-1的位置，依次向前填充，不会覆盖num1前面的元素因为后面的元素都是空的，直到所有的元
function merge(nums1, m, nums2, n) {
    let i = m - 1;    // nums1 有效元素的末尾
    let j = n - 1;    // nums2 的末尾
    let k = m + n - 1; // 合并后的末尾

    // 反向遍历，填充较大元素
    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j]) {
            nums1[k] = nums1[i];
            i--;
        } else {
            nums1[k] = nums2[j];
            j--;
        }
        k--;
    }

    // 处理 nums2 剩余元素（若存在）
    while (j >= 0) {
        nums1[k] = nums2[j];
        j--;
        k--;
    }
}
