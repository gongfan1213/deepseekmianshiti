手写事件委托的变式及异步回调处理
- 5.手写事件委托的变式，要求可以指定父元素parent，标签名tagName，事件名event，事件回调callback，万一我们在父元素需要用到回调函数的结果，但是回调函数是异步的该怎么办，一直搞不懂面试官什么意思😭，也寄掉


事件委托的基本概念

事件委托是一种常用的技术，它利用事件冒泡的原理，将事件监听器添加到父元素上，而不是每个子元素上。这样可以减少内存消耗，提高性能。

实现事件委托的变式

下面是一个可以指定父元素 parent、标签名 tagName、事件名 event 和事件回调 callback 的事件委托函数：

javascript
Copy Code
function eventDelegation(parent, tagName, event, callback) {
    // 获取父元素
    const parentElement = document.querySelector(parent);
    
    // 为父元素添加事件监听器
    parentElement.addEventListener(event, function(e) {
        // 获取事件目标元素
        const target = e.target;
        
        // 检查事件目标元素是否是指定标签名的元素
        if (target.tagName.toLowerCase() === tagName.toLowerCase()) {
            // 调用回调函数，并传入事件目标元素作为参数
            callback(target);
        }
    });
}

处理异步回调函数的结果

如果回调函数是异步的，并且父元素需要在回调完成后使用其结果，那么我们需要一种机制来等待异步操作完成。这通常可以通过使用 Promise 或 async/await 来实现。

下面是一个修改后的版本，它支持异步回调函数，并允许父元素在回调完成后处理结果：

javascript
Copy Code
function eventDelegationAsync(parent, tagName, event, asyncCallback) {
    // 获取父元素
    const parentElement = document.querySelector(parent);
    
    // 为父元素添加事件监听器
    parentElement.addEventListener(event, async function(e) {
        // 获取事件目标元素
        const target = e.target;
        
        // 检查事件目标元素是否是指定标签名的元素
        if (target.tagName.toLowerCase() === tagName.toLowerCase()) {
            // 调用异步回调函数，并传入事件目标元素作为参数
            try {
                const result = await asyncCallback(target);
                
                // 在这里处理异步回调的结果
                // 例如，可以将结果存储在父元素的某个属性中
                parentElement.resultFromCallback = result;
                
                // 或者执行其他需要的操作
                console.log('异步回调结果:', result);
            } catch (error) {
                // 处理异步回调中的错误
                console.error('异步回调出错:', error);
            }
        }
    });
}

使用示例

假设我们有一个按钮点击事件，该事件是异步的，并且我们希望在父元素中存储点击按钮的文本内容：

javascript
Copy Code
// 异步回调函数，模拟一个异步操作（例如，从服务器获取数据）
async function asyncButtonClickHandler(button) {
    // 模拟异步延迟
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(button.textContent);
        }, 1000);
    });
}

// 使用事件委托函数
eventDelegationAsync('#parent', 'button', 'click', asyncButtonClickHandler);


在这个示例中，当按钮被点击时，asyncButtonClickHandler 会被调用，并且父元素 #parent 会在异步操作完成后存储按钮的文本内容。

注意事项
确保父元素选择器 parent 是有效的，并且父元素在 DOM 中存在。
异步回调函数 asyncCallback 应该返回一个 Promise，以便可以使用 await 关键字等待其结果。
在处理异步回调结果时，要注意错误处理，以避免未捕获的异常导致程序崩溃。